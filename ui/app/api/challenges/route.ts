import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs/promises'
import path from 'path'
import { DATA_DIR, PATHS } from '@/lib/paths'

export async function GET() {
  try {
    const challengesDir = PATHS.challenges

    // Ensure directory exists
    await fs.mkdir(challengesDir, { recursive: true })

    const dirs = await fs.readdir(challengesDir, { withFileTypes: true })
    const challenges = []

    for (const dir of dirs) {
      if (dir.isDirectory()) {
        try {
          const configPath = path.join(challengesDir, dir.name, 'challenge-config.json')
          const configContent = await fs.readFile(configPath, 'utf-8')
          const config = JSON.parse(configContent)

          // Calculate progress (days completed / total days)
          const startDate = new Date(config.start_date || config.startDate)
          const endDate = new Date(config.end_date || config.targetDate)
          const today = new Date()
          const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))
          const daysElapsed = Math.ceil((today.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))
          const progress = config.progress !== undefined
            ? config.progress
            : Math.min(Math.round((daysElapsed / totalDays) * 100), 100)

          // Build proper streak object from config
          const streakData = config.streak || {}
          const streak = {
            id: `streak-${config.id}`,
            challengeId: config.id,
            current: streakData.current || 0,
            best: streakData.best || streakData.longest || 0,
            lastCheckin: streakData.lastCheckin || null,
            missedDays: streakData.missedDays || 0,
            graceUsed: streakData.graceUsed || 0
          }

          challenges.push({
            id: config.id,
            name: config.name,
            type: config.type,
            goal: config.goal,
            agent: config.agent || 'accountability-coach',
            startDate: config.start_date || config.startDate,
            targetDate: config.end_date || config.targetDate,
            status: config.status || 'active',
            streak,
            progress,
            totalDays: totalDays > 0 ? totalDays : 30,  // Include total days for the challenge
            punishments: config.punishments || [],
            gracePeriod: config.grace_period || config.gracePeriod || 24,
            dailyHours: config.daily_hours || config.dailyHours || 1,
            availableSlots: config.available_slots || config.availableSlots || [],
            milestones: config.milestones || []
          })
        } catch (error) {
          console.error(`Error reading challenge ${dir.name}:`, error)
        }
      }
    }

    return NextResponse.json({ challenges })
  } catch (error) {
    console.error('Error fetching challenges:', error)
    return NextResponse.json({ challenges: [] })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      id,
      name,
      type,
      agent,
      goal,
      startDate,
      targetDate,
      dailyHours,
      availableSlots,
      punishments,
      gracePeriod,
    } = body

    const challengesDir = PATHS.challenges
    const challengeDir = path.join(challengesDir, id)

    // Create challenge directory
    await fs.mkdir(challengeDir, { recursive: true })

    // Create challenge config
    const config = {
      id,
      name,
      type,
      agent,
      goal,
      start_date: startDate,
      end_date: targetDate,
      daily_hours: dailyHours,
      available_slots: availableSlots,
      punishments: punishments || [],
      grace_period: gracePeriod || 0,
      status: 'active',
      created_at: new Date().toISOString(),
    }

    await fs.writeFile(
      path.join(challengeDir, 'challenge-config.json'),
      JSON.stringify(config, null, 2),
      'utf-8'
    )

    // Create initial plan.md
    await fs.writeFile(
      path.join(challengeDir, 'plan.md'),
      `# ${name}\n\n## Goal\n${goal}\n\n## Plan\n\n(Plan will be generated by AI based on your goal and timeline)\n`,
      'utf-8'
    )

    // Create activity-log.md (daily check-ins and activities)
    await fs.writeFile(
      path.join(challengeDir, 'activity-log.md'),
      `# Activity Log - ${name}\n\nStarted: ${startDate}\n\n## Daily Activities\n\n`,
      'utf-8'
    )

    // Create progress.md (overall progress tracking)
    await fs.writeFile(
      path.join(challengeDir, 'progress.md'),
      `# Progress - ${name}\n\nStarted: ${startDate}\nTarget: ${targetDate}\n\n## Overall Progress\n\n**Current Status:** Just started\n**Progress:** 0%\n**Streak:** 0 days ðŸ”¥\n\n## Milestones\n\n- [ ] Week 1 Complete\n- [ ] Week 2 Complete\n- [ ] First Major Milestone\n- [ ] Halfway Point\n- [ ] Final Goal Achieved\n\n## Weekly Summary\n\n`,
      'utf-8'
    )

    // Create backlog.md (pending tasks and ideas)
    await fs.writeFile(
      path.join(challengeDir, 'backlog.md'),
      `# Backlog - ${name}\n\nLast Updated: ${new Date().toISOString().split('T')[0]}\n\n## Pending Tasks\n\n### ðŸ”´ High Priority (Do This Week)\n- [ ] Get started with ${name}\n\n### ðŸŸ¡ Medium Priority (Next 2 Weeks)\n\n### ðŸŸ¢ Low Priority (Nice to Have)\n\n## Ideas & Future Projects\n\n## Resources to Explore\n\n## Blockers to Resolve\n\n## Completed This Week âœ…\n`,
      'utf-8'
    )

    // Create punishment.json (punishment configuration)
    const punishmentConfig = {
      punishments: punishments || [],
      active: punishments && punishments.length > 0,
      grace_period_hours: gracePeriod || 24,
      triggered: [],
      history: []
    }
    await fs.writeFile(
      path.join(challengeDir, 'punishment.json'),
      JSON.stringify(punishmentConfig, null, 2),
      'utf-8'
    )

    // Update registry
    const registryPath = path.join(DATA_DIR, '.registry', 'challenges.json')
    let registry: any = { challenges: [] }
    try {
      const registryContent = await fs.readFile(registryPath, 'utf-8')
      registry = JSON.parse(registryContent)
    } catch {
      await fs.mkdir(path.join(DATA_DIR, '.registry'), { recursive: true })
    }

    registry.challenges = registry.challenges || []
    registry.challenges.push({
      id,
      name,
      streak: 0,
      last_checkin: null,
      status: 'active',
    })

    await fs.writeFile(registryPath, JSON.stringify(registry, null, 2), 'utf-8')

    // Log to index.md
    try {
      await fetch(`${request.nextUrl.origin}/api/system/index`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'challenge_created',
          data: {
            id,
            name,
            type,
            progress: 0,
            streak: 0,
            punishment: punishments?.length > 0 ? punishments[0].consequence.type : 'none',
          },
        }),
      })

      // Also log files created
      await fetch(`${request.nextUrl.origin}/api/system/index`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'file_created',
          data: {
            filePath: `challenges/${id}/challenge-config.json`,
            purpose: 'Challenge configuration',
            created: new Date().toISOString(),
            modified: new Date().toISOString(),
          },
        }),
      })

      await fetch(`${request.nextUrl.origin}/api/system/index`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'file_created',
          data: {
            filePath: `challenges/${id}/plan.md`,
            purpose: 'Challenge plan',
            created: new Date().toISOString(),
            modified: new Date().toISOString(),
          },
        }),
      })
    } catch (error) {
      console.error('Failed to update index.md:', error)
      // Don't fail the request if index update fails
    }

    return NextResponse.json({
      success: true,
      challenge: {
        id,
        name,
        type,
        streak: 0,
        progress: 0,
        isActive: true,
      },
    })
  } catch (error: any) {
    console.error('Error creating challenge:', error)
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    )
  }
}
